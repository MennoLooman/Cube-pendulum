%% settings
if ~exist('h','var')
    h = 0.01; %based on rise time of pendulum swing (also used during estimation, but could now independently altered here.
end

%COST TERMS
if ~exist('stable_equi','var')
    stable_equi = 0;
end

if(stable_equi)
    %settings stable equi
    Horizon_P; %prediction horizon
    Horizon_C; %controller horizon
    Q; %Q tuning states 4x4
    R; %R tuning input 1x1
    beta; %weight on terminal cost
    alpha_upp; %upper bound for alpha
    alpha_low; %lower bound for alpha
else
    %settings unstable equi
    Horizon_P; %prediction horizon
    Horizon_C; %controller horizon
    Q; %Q tuning states 4x4
    R; %R tuning input 1x1
    beta; %weight on terminal cost
    alpha_bound; %upper and lower bound for alpha
end

%% get system matrices and kalm-filter observer
addpath '..\observer'
plot_figure = 0;
observer_script; %gives Ad,Bd,Cd,Dd

%% make MPC controller
Co = ctrb(Ac,Bc);
if( length(Ac)-rank(Co) ~= 0)
    disp("system is not controllable.");
    return
else
    disp("system is controllable.");
end

% get Penalty matrix P for final state
[P_are,~,~,P_info] = idare(Ad,Bd,Q,R,[],[]);
P = beta * P_are; % used for: 1/2 x(N)' P x(N)

if P_info.Report > 0
   error("solve_DARE: DARE not solved properly"); 
end

%sys behaviour
Aeq = [[eye(4*(Horizon_P+1)) + kron(diag(ones(1,Horizon_P),-1),-Ad)] [zeros(4,Horizon_P); kron(eye(Horizon_P),-Bd)]];
beq = [x0; zeros(4*Horizon_P,1)]; 

%constraints
Aleq = [[zeros(2*Horizon_P,4*(Horizon_P+1)) kron(eye(Horizon_P),[1;-1])];
        [zeros(2*Horizon_P,4) kron(eye(Horizon_P),[0 0 0 1; 0 0 0 -1]) zeros(2*Horizon_P,Horizon_P)]];
bleq = [ones(2*Horizon_P,1); alpha_bound*ones(2*Horizon_P,1)];

%Objective function
